"use strict";(self.webpackChunkresearch=self.webpackChunkresearch||[]).push([[9121],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var s=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,s)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function n(e,t){if(null==e)return{};var r,s,o=function(e,t){if(null==e)return{};var r,s,o={},i=Object.keys(e);for(s=0;s<i.length;s++)r=i[s],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)r=i[s],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=s.createContext({}),l=function(e){var t=s.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=l(e.components);return s.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,u=n(e,["components","mdxType","originalType","parentName"]),p=l(r),d=o,m=p["".concat(c,".").concat(d)]||p[d]||h[d]||i;return r?s.createElement(m,a(a({ref:t},u),{},{components:r})):s.createElement(m,a({ref:t},u))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=d;var n={};for(var c in t)hasOwnProperty.call(t,c)&&(n[c]=t[c]);n.originalType=e,n[p]="string"==typeof e?e:o,a[1]=n;for(var l=2;l<i;l++)a[l]=r[l];return s.createElement.apply(null,a)}return s.createElement.apply(null,r)}d.displayName="MDXCreateElement"},4489:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});var s=r(7462),o=(r(7294),r(3905));const i={title:"Account signatures and keys in Polkadot"},a=void 0,n={unversionedId:"Polkadot/security/keys/accounts-more",id:"Polkadot/security/keys/accounts-more",title:"Account signatures and keys in Polkadot",description:"We believe Polkadot accounts should primarily use Schnorr signatures with both public keys and the R point in the signature encoded using the Ristretto point compression for the Ed25519 curve.  We should collaborate with the dalek ecosystem for which Ristretto was developed, but provide a simpler signature crate, for which schnorr-dalek provides a first step.",source:"@site/docs/Polkadot/security/keys/1-accounts-more.md",sourceDirName:"Polkadot/security/keys",slug:"/Polkadot/security/keys/accounts-more",permalink:"/Polkadot/security/keys/accounts-more",draft:!1,editUrl:"https://github.com/w3f/research/blob/master/docs/Polkadot/security/keys/1-accounts-more.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Account signatures and keys in Polkadot"},sidebar:"sidebar",previous:{title:"Account signatures and keys",permalink:"/Polkadot/security/keys/accounts"},next:{title:"Nomination",permalink:"/Polkadot/security/keys/staking"}},c={},l=[{value:"Schnorr signatures",id:"schnorr-signatures",level:2},{value:"Curves",id:"curves",level:2},{value:"How much secp256k1 support?",id:"how-much-secp256k1-support",level:3},{value:"Is secp256k1 risky?",id:"is-secp256k1-risky",level:3},{value:"Is Ed25519 risky?  Aka use Ristretto",id:"is-ed25519-risky--aka-use-ristretto",level:3},{value:"Zero-knowledge proofs in the dalek ecosystem",id:"zero-knowledge-proofs-in-the-dalek-ecosystem",level:3}],u={toc:l},p="wrapper";function h(e){let{components:t,...r}=e;return(0,o.kt)(p,(0,s.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"We believe Polkadot accounts should primarily use Schnorr signatures with both public keys and the ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," point in the signature encoded using the ",(0,o.kt)("a",{parentName:"p",href:"https://ristretto.group"},"Ristretto")," point compression for the Ed25519 curve.  We should collaborate with the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/dalek-cryptography"},"dalek ecosystem")," for which Ristretto was developed, but provide a simpler signature crate, for which ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/w3f/schnorr-dalek"},"schnorr-dalek")," provides a first step."),(0,o.kt)("h2",{id:"schnorr-signatures"},"Schnorr signatures"),(0,o.kt)("p",null,"We prefer Schnorr signatures because they satisfy the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki"},"Bitcoin Schnorr wishlist")," and work fine with extremely secure curves, like the Ed25519 curve or secp256k1.  "),(0,o.kt)("p",null,"We observe the Bitcoin Schnorr wishlist oversells the promise of schnorr multi-signatures because they actually require three round trips, which works for industrial usage, but complicates.  Another scheme call mBCJ from pages 21 and 22 of ",(0,o.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2018/417.pdf"},"https://eprint.iacr.org/2018/417.pdf")," provides a two round trip multi-signature, but we require a delinearized variant of mBCJ for accounts ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/w3f/schnorrkel/issues/15"},"https://github.com/w3f/schnorrkel/issues/15")," and mBCJ is not actually a Schnorr signatures. "),(0,o.kt)("p",null,"You could do fancier tricks, including like aggregation, with a pairing based curve like BLS12-381 and the BLS signature scheme.  These curves are slower for single verifications, and worse accounts should last decades while pairing friendly curves should be expected become less secure as number theory advances.  "),(0,o.kt)("p",null,"There is one sacrifice we make by choosing Schnorr signatures over ECDSA signatures for account keys:  Both require 64 bytes, but only ",(0,o.kt)("a",{parentName:"p",href:"https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work"},"ECDSA signatures communicate their public key"),".  There are obsolete Schnorr variants that ",(0,o.kt)("a",{parentName:"p",href:"https://crypto.stackexchange.com/questions/60825/schnorr-pubkey-recovery"},"support recovering the public key from a signature"),", but\nthey break important functionality like ",(0,o.kt)("a",{parentName:"p",href:"https://www.deadalnix.me/2017/02/17/schnorr-signatures-for-not-so-dummies/"},"hierarchical deterministic key derivation"),".  In consequence, Schnorr signatures often take an extra 32 bytes for the public key."),(0,o.kt)("p",null,"In exchange, we gain a slightly faster signature scheme with far simpler batch verification than ",(0,o.kt)("a",{parentName:"p",href:"http://cse.iitkgp.ac.in/~abhij/publications/ECDSA-SP-ACNS2014.pdf"},"ECDSA batch verification")," and more natural threshold and multi-signatures, as well as tricks used by payment channels.  I also foresee the presence of this public key data may improve locality in block verification, possibly openning up larger optimisations."),(0,o.kt)("p",null,"Yet most importantly, we can protect Schnorr signatures using both the derandomization tricks of EdDSA along with a random number generator, which gives us stronger side-channel protections than conventional ECDSA schemes provide.  If we ever do want to support ECDSA as well, then we would first explore improvements in side-channel protections like ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc6979"},"rfc6979"),", along with concerns like batch verification, etc."),(0,o.kt)("h2",{id:"curves"},"Curves"),(0,o.kt)("p",null,"There are two normal curve choices for accounts on a blockchain system, either secp256k1 or the Ed25519 curve, so we confine our discussion to them.  If you wanted slightly more speed, you might choose FourQ, but it sounds excessive for blockchains, implementations are rare, and it appears covered by older but not quite expired patents.  Also, you might choose Zcash's JubJub if you wanted fast signature verification in zkSNARKs, but that's not on our roadmap for Polkadot, and Jubjub also lacks many implementations."),(0,o.kt)("h3",{id:"how-much-secp256k1-support"},"How much secp256k1 support?"),(0,o.kt)("p",null,'We need some minimal support for secp256k1 keys because token sale accounts are tied to secp256k1 keys on Ethereum, so some "account" type must necessarily use secp256k1 keys.  At the same time, we should not encourage using the same private keys on Ethereum and Polkadot.  We might pressure users into switching key types in numerous ways, like secp256k1 accounts need not support balance increases, or might not support anything but replacing themselves with an ed25519 key.  There are conceivable reasons for fuller secp256k1 support though, like wanting ethereum smart contracts to verify some signatures on Polkadot.  We might support secp256k1 accounts with limited functionality, but consider expanding that functionality if such use cases arise. '),(0,o.kt)("h3",{id:"is-secp256k1-risky"},"Is secp256k1 risky?"),(0,o.kt)("p",null,"There are two theoretical reasons for preferring an twisted Edwards curve over secp256k1:  First, secp256k1 has a ",(0,o.kt)("a",{parentName:"p",href:"https://safecurves.cr.yp.to/disc.html"},"small CM field discriminant"),", which might yield better attacks in the distant future.  Second, secp256k1 has fairly rigid paramater choices but ",(0,o.kt)("a",{parentName:"p",href:"https://safecurves.cr.yp.to/rigid.html"},"not the absolute best"),".  I do not believe either to be serious cause for concern.  Among more practical curve weaknesses, secp256k1 does have ",(0,o.kt)("a",{parentName:"p",href:"https://safecurves.cr.yp.to/twist.html"},"twist security")," which eliminates many attack classes.  "),(0,o.kt)("p",null,"I foresee only one substancial reason for avoiding secp256k1:  All short Weierstrass curves like secp256k1 have ",(0,o.kt)("a",{parentName:"p",href:"https://safecurves.cr.yp.to/complete.html"},"incomplete addition formulas"),", meaning certain curve points cannot be added to other curve points.  As a result, addition code must check for failures, but these checks make writing constant time code harder.  We could examine any secp256k1 library we use in Polkadot to ensure it both does these checks and has constant-time code.  We cannot however ensure that all implementations used by third party wallet software does so."),(0,o.kt)("p",null,"I believe incomplete addition formulas looks relatively harmless when used for simple Schnorr signatures, although forgery attacks might exist.  I'd worry more however if we began using secp256k1 for less well explored protocols, like multi-signaturtes and key derivation.   We ware about such use cases however, especially those listed in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki"},"Bitcoin Schnorr wishlist"),".  "),(0,o.kt)("h3",{id:"is-ed25519-risky--aka-use-ristretto"},"Is Ed25519 risky?  Aka use Ristretto"),(0,o.kt)("p",null,"Any elliptic curve used in cryptography has order h*l where l is a big prime, normally close to a power of two, and h is some very small number called the cofactor.  Almost all protocol implementations are complicated by these cofactors, so implementing complex protocols is safer on curves with cofactor h=1 like secp256k1.  "),(0,o.kt)("p",null,'The Ed25519 curve has cofactor 8 but a simple convention called "clamping" that makes two particularly common protocols secure.  We must restrict or drop "clamping" for more complex protocols, like multi-signaturtes and key derivation, or anything else in the ',(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki"},"Bitcoin Schnorr wishlist"),".  "),(0,o.kt)("p",null,'If we simple dropped "clamping" then we\'d make implementing protocols harder, but luckily the ',(0,o.kt)("a",{parentName:"p",href:"https://ristretto.group"},"Ristretto")," encoding for the Ed25519 curve ensures we avoid any curve points with 2-torsion.  I thus recommend:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'our secret key continue being Ed25519 "expanded" secret keys, while'),(0,o.kt)("li",{parentName:"ul"},'our on-chain encoding, aka "point compression" becomes Ristretto for both public keys and the ',(0,o.kt)("inlineCode",{parentName:"li"},"R")," component of Schnorr signatures. ")),(0,o.kt)("p",null,'In principle, we could use the usual Ed25519 "mini" secret keys for simple use cases, but not when doing key derivation.  We could thus easily verify standrad Ed25519 signatures with Ristretto encoded public keys.  We should ideally use Ristretto throughout instead of the standard Ed25519 point compression.  '),(0,o.kt)("p",null,"In fact, we can import standard Ed25519 compressed points like I do ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/w3f/schnorr-dalek/blob/master/src/ristretto.rs#L877"},"here")," but this requires the scalar exponentiation done in the ",(0,o.kt)("a",{parentName:"p",href:"https://doc.dalek.rs/curve25519_dalek/edwards/struct.EdwardsPoint.html#method.is_torsion_free"},(0,o.kt)("inlineCode",{parentName:"a"},"is_torsion_free")," method"),", which runs slower than normal signature verification.  We might ideally do this only for key migration between PoCs."),(0,o.kt)("p",null,"Ristretto is far simpler than the Ed25519 curve itself, so Ristretto can be added to Ed25519 implementations, but the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/dalek-cryptography/curve25519-dalek"},"curve25519-dalek")," crate already provides a highly optimised rust implementation."),(0,o.kt)("h3",{id:"zero-knowledge-proofs-in-the-dalek-ecosystem"},"Zero-knowledge proofs in the dalek ecosystem"),(0,o.kt)("p",null,"In fact, the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/dalek-cryptography"},"dalek ecosystem")," has an remarkably well designed infrastructure for zero-knowledge proofs without pairings.  See:\n",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/interstellar/bulletproofs-pre-release-fcb1feb36d4b"},"https://medium.com/interstellar/bulletproofs-pre-release-fcb1feb36d4b"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/interstellar/programmable-constraint-systems-for-bulletproofs-365b9feb92f7"},"https://medium.com/interstellar/programmable-constraint-systems-for-bulletproofs-365b9feb92f7")),(0,o.kt)("p",null,"All these crates use Ristretto points so using Ristretto for account public keys ourselves gives us the most advanced tools for building protocols not based on pairings, meaning that use our account keys.  In principle, these tools might be abstracted for twisted Edwards curves like FourQ and Zcash's Jubjub, but yu might loose some batching operations in abstracting them for short Weierstrass curves like secp256k1."))}h.isMDXComponent=!0}}]);